We can create multiple authentication filters, and multiple authentication providers. Make sure that each authentication filter corresponds to one authentication provider.
For example, we can create a username-password, email-password, and OAuth google authentication provider, we must also create a authentication filter that supports it. So that it can create the proper authentication object

UserDetails and UserDetailService
    UserDetails defines what a user is.
    UserDetailsService defines how to fetch that user when needed (e.g., during authentication).

When creating a project in scratch, I would first think about the security side first. I would look at how the Authentication Logic and implement it depending on the applications' needs.
Think about the strategy that you will use in the security context. Each strategy vary depending on your case.
    Strategies:
        * MODE_THREADLOCAL
        * MODE_INHERITEDTHREADLOCAL
        * MODE_GLOBAL

    Didn't really learn or dove deep in the threads or strategies, since I figured that I won't really need to customize it. Might learn it later if needed for my project.


10/29/2025

    AuthenticationEntryPoint()
        I was introduced to Entry Points, it’s the component that handles what happens when a user tries to access a protected resource without being authenticated.
        We can use entry point on these two methods in the SecurityConfig() method, either on the http.httpBasic() or http.exceptionHandling().

            Use entry point on http.httpBasic() when:
                “Whenever HTTP Basic authentication is used and fails or is missing credentials, use this entry point.”

            Use entry point on http.exceptionHandling() when:
                “Whenever an unauthenticated request tries to access a protected resource — regardless of mechanism — use this entry point globally.”

        The best approach is to use both if possible.


    Authentication Handler

        AuthenticationSuccessHandler()
            is the component you implement when you want further customization whenever a successful log in

        AuthenticationFailureHandler()
            is the component you implement when you want further customization whenever a failed log in occurs.


    The difference between EntryPoint and AuthenticationHandler:
        "In Spring Security, an **AuthenticationEntryPoint** and an **AuthenticationHandler** serve different roles in the authentication flow. The **AuthenticationEntryPoint** is triggered when a user tries to access a protected resource **without being authenticated**, meaning no credentials were provided at all. It decides how the system should respond—such as returning a `401 Unauthorized` for APIs or redirecting to a login page for web apps. On the other hand, an **AuthenticationHandler** (specifically the `AuthenticationSuccessHandler` and `AuthenticationFailureHandler`) is used **after a login attempt** has been made. The success handler runs when authentication succeeds (e.g., logging in successfully), while the failure handler runs when authentication fails (e.g., wrong username or password).
        In short, the entry point handles *unauthenticated access*, while the handlers deal with *the result of an authentication attempt*."
10/30/2025

    Authorization
        Authorization is the process during which the system decides if the authenticated user is authorized to access a particular resource.

        hasAuthority() and hasAnyAuthority()
            These methods are used in the security config mainly in the http.authorizeHttpRequests(c -> c.anyRequest().hasAuthority("write") or .hasAnyAuthority("write", "read")).
            This tell spring to check the authority of a authenticated user if they have the following authority, if not the request is rejected and a 403 is returned

                hasAuthority('WRITE')—Stipulates that the user needs the WRITE
                authority to call the endpoint.

                hasAnyAuthority('READ', 'WRITE')—Specifies that the user needs
                one of either the READ or WRITE authorities. With this expression, you
                can enumerate all the authorities for which you want to allow access

        hasRole() and hasAnyRole()
            Both are used the same way as the previous methods. It's used on http.authorizeHttpRequests(c -> c.anyRequest.hasRole("ADMIN")) or http.authorizeHttpRequest.hasAnyRole("ADMIN", "STAFF").

            hasRole()
                Checks whether the current authenticated user has a specific role. Spring automatically adds the prefix "ROLE_" before checking.

            hasAnyRole()
                Checks whether the current authenticated user has any one of the given role. Spring automatically adds the prefix "ROLE_" before checking.


        access()
            Is a flexible, generic method that allows you to write any Spring Security expression (not just role checks).
            We could say that with the access() method, you can basically implement any kind of rule. The possibilities are endless. Just don’t forget that in applications, we always strive to keep syntax as simple as possible. Complicate your configurations only when you don’t have any other choice.

        Endpoints restriction
            Currently, we are implementing the authorization on any of the endpoints by using the .anyRequest() from http.authorizeHttpRequest(c -> c.anyRequest()); This means that all the authorization logic is used or applied on every endpoint

        How to implement, create users with roles or authorities fields. Then implement it using a custom UserDetailsService and UserDetails. From there implement it in the security config http.authorizeHttpRequests(c -> c.anyRequest().hadRole("Admin")

10/31/2025

    Authentication Filter and Authorization Filter

        Authentication Filter

            Purpose:

                The authentication filter is responsible for verifying who the user is — in other words, checking the user’s identity.

            Typical Behavior:

                It intercepts incoming requests before access is granted.

                Extracts credentials (like username/password, JWT token, API key, etc.).

                Delegates authentication to an AuthenticationManager, which validates them (e.g., checking username and password against the database).

                If valid, it stores the authentication object in the SecurityContext.

                If invalid, it blocks the request and returns an authentication error (401 Unauthorized

        Authorization Filter

            Purpose:

                The authorization filter determines what the authenticated user is allowed to do — in other words, checking their permissions or roles.

            Typical Behavior:

                Runs after authentication.

                Reads the SecurityContext (which now contains the authenticated user).

                Checks if the user has the necessary authority/role for the requested resource.

                If access is allowed → proceeds.

                If not → returns access denied (403 Forbidden).

                Example in Spring Security:

                AuthorizationFilter (introduced in newer versions of Spring Security 6).

                FilterSecurityInterceptor (older mechanism, used before the new chain).

                Configured via methods like:

                    http.authorizeHttpRequests(auth ->
                        auth.requestMatchers("/admin/**").hasRole("ADMIN")
                    );


    Authorization Summary

        Authorization is the process during which the application decides if an authenticated request is permitted or not. Authorization always happens after authentication.

        You configure how the application authorizes requests based on the authorities and roles of an authenticated user.

        In your application, you can also specify that certain requests are possible for unauthenticated users.

        You can configure your app to reject any request, using the denyAll() method, or permit any requests, using the permitAll() method

11/1/2025
 - No learnings since all souls day.

11/2/2025
- No Learnings since all saints day.

11/3/2025
- No Learnings, focused on assembly that day.

11/4/2025

    Configuring Endpoint level authorization: Applying restrictions

        requestMatchers()

            This method is used in the security configuration, specifically within the authorizeHttpRequests() method. Previously, we used anyRequest(), which means that any incoming request — regardless of the endpoint or HTTP method — will be subject to the same authorization rule.
            On the other hand, requestMatchers() is used to define authorization rules for specific endpoints or URL patterns. Only the requests that match the specified patterns will trigger the corresponding authorization rule. This allows developers to apply different access controls to different endpoints.

            NOTE

                When you use matchers to refer to requests, the order of the rules should be from particular to general. This is why the anyRequest() method cannot be called before a more specific requestMatchers() method.


11/5/2025
    -Spent time doing Numerical Analysis

11/6/2025

    Configuring endpoint level authorization: Applying restrictions on specific endpoints

    We can use the ** operator to group endpoints having the same starting path. For example requestMatchers("/a/**").authenticated(), this means that any endpoint starting with /a will be authenticated. /a/b/c/d, /a/c/b and so on.

            c -> c.requestMatchers("/api/**").authenticated()

    We can also reject a request if the endpoint path variable isn't what we're accepting for example, we have an endpoint of /product/code/{codeNumber} which only accepts digits on the codeNumber, we can configure the security to accept only the request having digits. By doing:

            Uses the /a/{param:regex}

            c -> c.requestMatchers("/product/code/{code:^[0-9]*$").authenticated()
                 c.anyRequest().denyAll()

    TODO: Learn Regex

11/7/2025

    Endpoint Level Authorization Summary:

        In real-world scenarios, you often apply different authorization rules for different requests.

        You specify the requests for which authorization rules are configured based on path and HTTP method. To do this, you use the requestMatchers() method.

        When requirements are too complex to be solved with path expressions, you can implement them with the more powerful regexes.


    9. Configuring CSRF (Cross Site Request Forgery) protection

       CSRF attacks assume that a user is logged into a web application. They’re tricked by the attacker into opening a page that contains scripts that execute actions in the same application the user was working on. Because the user has already logged in (as we’ve assumed from the beginning), the forgery code can now impersonate the user and do actions on their behalf.

       How do we protect our users from such scenarios? What CSRF protection wants to ensure is that only the frontend of web applications can perform mutating operations (by convention, HTTP methods other than GET, HEAD, TRACE, or OPTIONS). Then, a foreign page, like the one in our example, can’t act on behalf of the user.

       By default, csrf is enabled. As you know by now, you are not able to call endpoints with POST directly without disabling CSRF protection.

       To implement csrf, we just don't have to disable it in the security config. But we need to create a filter that retrieves the csrf token and find a way to send it to the client.

       Csrf uses the CsrfTokenRepository which uses a sessionID or cookie along with the csrf token, so by default we need to specify both the sessionID and csrf token.
















