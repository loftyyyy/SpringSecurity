We can create multiple authentication filters, and multiple authentication providers. Make sure that each authentication filter corresponds to one authentication provider.
For example, we can create a username-password, email-password, and OAuth google authentication provider, we must also create a authentication filter that supports it. So that it can create the proper authentication object

UserDetails and UserDetailService
    UserDetails defines what a user is.
    UserDetailsService defines how to fetch that user when needed (e.g., during authentication).

When creating a project in scratch, I would first think about the security side first. I would look at how the Authentication Logic and implement it depending on the applications' needs.
Think about the strategy that you will use in the security context. Each strategy vary depending on your case.
    Strategies:
        * MODE_THREADLOCAL
        * MODE_INHERITEDTHREADLOCAL
        * MODE_GLOBAL

    Didn't really learn or dove deep in the threads or strategies, since I figured that I won't really need to customize it. Might learn it later if needed for my project.


10/29/2025

    AuthenticationEntryPoint()
        I was introduced to Entry Points, it’s the component that handles what happens when a user tries to access a protected resource without being authenticated.
        We can use entry point on these two methods in the SecurityConfig() method, either on the http.httpBasic() or http.exceptionHandling().

            Use entry point on http.httpBasic() when:
                “Whenever HTTP Basic authentication is used and fails or is missing credentials, use this entry point.”

            Use entry point on http.exceptionHandling() when:
                “Whenever an unauthenticated request tries to access a protected resource — regardless of mechanism — use this entry point globally.”

        The best approach is to use both if possible.


    Authentication Handler

        AuthenticationSuccessHandler()
            is the component you implement when you want further customization whenever a successful log in

        AuthenticationFailureHandler()
            is the component you implement when you want further customization whenever a failed log in occurs.


    The difference between EntryPoint and AuthenticationHandler:
        "In Spring Security, an **AuthenticationEntryPoint** and an **AuthenticationHandler** serve different roles in the authentication flow. The **AuthenticationEntryPoint** is triggered when a user tries to access a protected resource **without being authenticated**, meaning no credentials were provided at all. It decides how the system should respond—such as returning a `401 Unauthorized` for APIs or redirecting to a login page for web apps. On the other hand, an **AuthenticationHandler** (specifically the `AuthenticationSuccessHandler` and `AuthenticationFailureHandler`) is used **after a login attempt** has been made. The success handler runs when authentication succeeds (e.g., logging in successfully), while the failure handler runs when authentication fails (e.g., wrong username or password).
        In short, the entry point handles *unauthenticated access*, while the handlers deal with *the result of an authentication attempt*."
10/30/2025

    Authorization
        Authorization is the process during which the system decides if the authenticated user is authorized to access a particular resource.

        hasAuthority() and hasAnyAuthority()
            These methods are used in the security config mainly in the http.authorizeHttpRequests(c -> c.anyRequest().hasAuthority("write") or .hasAnyAuthority("write", "read")).
            This tell spring to check the authority of a authenticated user if they have the following authority, if not the request is rejected and a 403 is returned

                hasAuthority('WRITE')—Stipulates that the user needs the WRITE
                authority to call the endpoint.

                hasAnyAuthority('READ', 'WRITE')—Specifies that the user needs
                one of either the READ or WRITE authorities. With this expression, you
                can enumerate all the authorities for which you want to allow access

        hasRole() and hasAnyRole()
            Both are used the same way as the previous methods. It's used on http.authorizeHttpRequests(c -> c.anyRequest.hasRole("ADMIN")) or http.authorizeHttpRequest.hasAnyRole("ADMIN", "STAFF").

            hasRole()
                Checks whether the current authenticated user has a specific role. Spring automatically adds the prefix "ROLE_" before checking.

            hasAnyRole()
                Checks whether the current authenticated user has any one of the given role. Spring automatically adds the prefix "ROLE_" before checking.


        access()
            Is a flexible, generic method that allows you to write any Spring Security expression (not just role checks).
            We could say that with the access() method, you can basically implement any kind of rule. The possibilities are endless. Just don’t forget that in applications, we always strive to keep syntax as simple as possible. Complicate your configurations only when you don’t have any other choice.

        Endpoints restriction
            Currently, we are implementing the authorization on any of the endpoints by using the .anyRequest() from http.authorizeHttpRequest(c -> c.anyRequest()); This means that all the authorization logic is used or applied on every endpoint

10/31/2025

    Authentication Filter and Authorization Filter

        Authentication Filter

            Purpose:

                The authentication filter is responsible for verifying who the user is — in other words, checking the user’s identity.

            Typical Behavior:

                It intercepts incoming requests before access is granted.

                Extracts credentials (like username/password, JWT token, API key, etc.).

                Delegates authentication to an AuthenticationManager, which validates them (e.g., checking username and password against the database).

                If valid, it stores the authentication object in the SecurityContext.

                If invalid, it blocks the request and returns an authentication error (401 Unauthorized

        Authorization Filter

            Purpose:

                The authorization filter determines what the authenticated user is allowed to do — in other words, checking their permissions or roles.

            Typical Behavior:

                Runs after authentication.

                Reads the SecurityContext (which now contains the authenticated user).

                Checks if the user has the necessary authority/role for the requested resource.

                If access is allowed → proceeds.

                If not → returns access denied (403 Forbidden).

                Example in Spring Security:

                AuthorizationFilter (introduced in newer versions of Spring Security 6).

                FilterSecurityInterceptor (older mechanism, used before the new chain).

                Configured via methods like:

                    http.authorizeHttpRequests(auth ->
                        auth.requestMatchers("/admin/**").hasRole("ADMIN")
                    );






